
软件的本质在于解决业务问题，以辅助业务而生存。
公司的业务创建的利润，所以合理解决业务问题才是关键。
这里的业务就是指一种领域
每一种业务都会涉及到一种知识体系，软件就是将这个知识体系表达出来。
--------------------------------------------------------------------------------
3个基本用途决定模型选择
1 模型和设计核心互相影响
2 模型是团队所有成员使用通用语言的中枢
3 模型是浓缩的知识
--------------------------------------------------------------------------------
有效建模的要素
1 模型和实现的绑定
2 建立了一种基于模型的语言
3 开发一个蕴含丰富知识的模型
4 提炼模型
5 头脑风暴和实验
--------------------------------------------------------------------------------
规则类的处理可以使用策略模式来解决
要找出模型中隐藏概念（如允许超订10%）
示例代码允许 10%超订
原始代码
public int makeBooking(Cargo cargo,Voyage voyage){
  double maxBooking=voyage.capacity()*1.1;
  if((voyage.bookedCargoSize()+cargo.size())>maxBooking)
      return -1;
  int confirmation=orderConfirmationSequence.next();
  voyage.addCargo(cargo,confirmation);
  return confirmation;
}

修改后代码，把这条规则抽象出来
public boolean isAllowed(Cargo cargo,Voyage voyage){
  return (cargo.size()+voyage.bookedCargoSize())<=
            (voyage.capacity()*1.1);
}

public int makeBooking(Cargo cargo,Voyage voyage){
  if(!overbookingpolicy.isAllowed(cargo,voyage))
      return -1;
  int confirmation=orderConfirmationSequence.next();
  voyage.addCargo(cargo,confirmation);
  return confirmation;
}
--------------------------------------------------------------------------------

模式 Ubiquitous Language统一语言
一个团队 一个项目 一种语言
将交流需求中用到的词语写到一个专门的文档中
词汇包括类与主要操作的名称
并不断更新这个文档中的词语与意思
每一个词语不应当有歧义，需要精确描述
对统一语言的修改就是对领域模型的修改

--------------------------------------------------------------------------------
模式 Model-Driven Design 领域驱动设计
两个基本要素
即模型要支持有效的实现
抽象出关键的领域知识

抽象类Abstract Net
抽象类实现类Net
抽象类实现类Bus
类Layout Rule

业务流程
1创建连线a0
Net a0 =new Net("a0);
2创建连线a1
Net a1 =new Net("a1);
3创建总线a
Bus a=new Bus("a");
4总线连接线a0
a.addNet(a0);
5总线连接线a1
a.addNet(a1);
6创建连线规则
NetRule minWidth4=NetRule.create(MIN_WIDTH,4);
7为总线绑定连线规则
a.assignRule(minWidth4);

abstract class AbstractNet{
  private Set rules;
  void assignRule(LayoutRule rule){
    rules.add(rule);
  }

 Set assignedRules(){
    return rules;
  }
}

class Net extends AbstractNet{
  private Bus bus;

  Set assignedRules(){
    Set result=new HashSet();
    result.addAll(super.assignedRules());
    result.addAll(bus.assignedRules());
    return result;
  }
}

服务列表
服务                  |职责
Net List import |读取Net列表文件，将每一行数据创建Net实例
Net Rule export|已知Net集合，将所有附加规则写入规则文件
Bus Repository |提供通过名称访问Bus（总线）的接口

工具类列表
类名                         |职责
Net Repository         |提供通过名称访问Net的接口
Inferred Bus Factory |已经Net集合，利用命名约定来推断总线，并且创建总线实例

现在，启动应用程序，用导入数据来初始化Net和Bus仓库。
Collection nets=NetListImportService.read(aFile);
NetRepository.addAll(nets);
Collection buses=InferredBusFactory.groupIntoBuses(nets);
BusRepository.addAll(buses);
--------------------------------------------------------------------------------
模式 Hands-On Modeler 亲身实践的建模者
--------------------------------------------------------------------------------
模式 Layered Architecture 分层架构
*用户界面层（或表示层）负责向用户显示信息和解释用户指令
这里的用户可以是另一个计算机系统，不一定是使用用户界面的人
*应用层 定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题。
这一层所负责的工作对业务来说意义重大，
也是与其他系统的应用层进行交互的必要渠道。
应用层要尽量简单，不包含业务规则或者知识，只为下一层中的领域对象协调任务，
分配工作使他们互相协作。它没有反映业务情况的状态，但可以具有另外一种状态，
为用户或程序显示某个任务的进度
*领域层（或模型层） 负责表达业务概念，业务状态信息以及业务规则。
尽管保存业务状态的技术细节是由基础设施层实现的，
但是反映业务情况的状态是由本层控制并且使用的。
领域层是业务软件的核心
*基础设施层 为上面各层提供通用的技术能力：为应用层传递消息，
为领域层提供持久化机制，
为用户界面层绘制屏幕组件，等等。
基础设施层还能够通过架构框架来支持4个层次间的交互模式
网上银行分层示例
用户界面层 transferController
应用层 fundsTransferService
领域层 a123:Account,a234:Account 两个账户对象
基础设施层 unit of work manager(事务处理与持久化JPA),O-R Mapper(持久化对象模型DTO)

流程说明
1. transferController->tranfer(a123,a234,100) 要转账
控制层调用转账方法，传入要转账的两个账户与转账金额，三个参数源账户，目标账户，转账金额
2. FundsTransferService-beginTransaction()->Unit of Work Manager 开启事务
应用层调用基础设施层的持久化单元开启事务
3. FundsTransferService-transferTo(a234,100)->a123:Account 领域模型Account实例a123
应用层调用本层的转账方法此方法会通知领域层a123领域模型要向a234领域模型转100
4. a123:Account -credit(100)->a234:Account 领域模型Account实例a234
领域层a123领域模型授信给a234领域模型100
5. a234:Account -addToUnitOfWork(a234)->Unit of Work Manager
领域层a234领域模型通知基础层持久化单元（注意这时候并没真正存储到库里）
6. a234:Account-confirm->a123:account
领域层a234确认收到a123信用100
7. a123:Account-debit(100)-a123
领域层a123领域模型自己记账100
8. a123:Account-addToUnitOfWork(a123)->Unit of Work Manager
领域层a123领域模型通知基础层持久化单元（注意这时候并没真正存储到库里）
9. a123:Account-confirm->FundsTransferService
领域层模型通知应用层服务这活确认搞完了
10. FundsTransferService-commit()->Unit of Work Manager
应用层服务通知基础层持久化单元你可以真正持久化到数据库了
11.Unit of WorkManager -update(collection)->O-R Mapper
基础层通过持久化模型将刚才改好的两个领域模型转换为关系数据库模型保存到库

--------------------------------------------------------------------------------
模式 Entity(Reference Objecct) 实体（引用对象）

--------------------------------------------------------------------------------
模式 Value Object 值对象（描述对象）

--------------------------------------------------------------------------------
模式  Service 服务

--------------------------------------------------------------------------------
模式 Module(Package) 模块(包）

--------------------------------------------------------------------------------
模式 Aggregate 聚合
--------------------------------------------------------------------------------
模式 Factory 工厂
--------------------------------------------------------------------------------
模式 Repository 仓库
--------------------------------------------------------------------------------
模式 Intention-Revealing Interfaces 释意接口
--------------------------------------------------------------------------------
模式 Side-Effect-Free function 无副作用的函数
--------------------------------------------------------------------------------
模式 Assertion 断言
--------------------------------------------------------------------------------
模式 Conceptual Contour 概念轮廓
--------------------------------------------------------------------------------
模式 Standalone Class 单例类
--------------------------------------------------------------------------------
模式 Closure of Operation 操作结束
--------------------------------------------------------------------------------
模式 Strategy(Policy) 策略
--------------------------------------------------------------------------------
模式 Composite 组合
--------------------------------------------------------------------------------
模式 Bounded Context
--------------------------------------------------------------------------------
模式 Continuous Integration
--------------------------------------------------------------------------------
模式 Context Map
--------------------------------------------------------------------------------
模式 Shared Kernel
--------------------------------------------------------------------------------
模式 Customer/Supplier Development Team
--------------------------------------------------------------------------------
模式 Conformist
--------------------------------------------------------------------------------
模式 Anticorruption Layer
--------------------------------------------------------------------------------
模式 Separate Way
--------------------------------------------------------------------------------
模式 Open Host Service
--------------------------------------------------------------------------------
模式 Published Language
--------------------------------------------------------------------------------
模式 Core Domain
--------------------------------------------------------------------------------
模式 Generic Subdomain
--------------------------------------------------------------------------------
模式 Domain Vision Statement
--------------------------------------------------------------------------------
模式 Highlighted Core
--------------------------------------------------------------------------------
模式 Cohesive Mechanism
--------------------------------------------------------------------------------
模式 Segregated Core
--------------------------------------------------------------------------------
模式 Abstract Core
--------------------------------------------------------------------------------
模式 Evolving Order
--------------------------------------------------------------------------------
模式 System Metaphor
--------------------------------------------------------------------------------
模式 Responsibility Layer
--------------------------------------------------------------------------------
模式 Knowledge Level
--------------------------------------------------------------------------------
模式 Pluggable Component Framework
--------------------------------------------------------------------------------







--------------------------------------------------------------------------------
模型都有哪些
视图模型VO 封装前端请求数据为对象
领域模型DM 收到对象并进行实际业务处理
数据模型DTO 将处理完成的结果领域模型转换为数据模型


--------------------------------------------------------------------------------
取款分层示例
应用层
public class TransactionApplicationService{
  @Autowired
  private IAccountRepository accountRepository;  
  public void withdraw(AccountId accountId, Integer amount){  
    Account account = accountRepository.find(new AccountSpecificationById(accountId)); // 找到用户账户
    account.withdraw(amount);  // 取款
    accountRepository.save(account);  // 保存账户状态
  }
}
领域层
private AccountId accountId;
  private Integer balance;
  
  public void withdraw(amount){
    if(balance < amount){
      throw new IllegalStateException("balance is not enough");  // 余额不够就不能取款
    }
    balance = balance - amount;
  }
}

TransactionApplication属于application层。

Account，IAccountRepository这些类属于domain层。

infrastructure里会有IAccountRepository的具体实现，这里没有写

请注意取款的具体逻辑是在Account类里的。如余额够不够，和金额的具体计算（虽然很简单）。
所以业务逻辑是在domain层。

TransactionApplication只是把具体的domain object找到，调用其开放的接口，不涉及具体逻辑。
上边的例子找到用户的账户，告诉账户对象扣钱（具体怎么扣不管），保存账户的状态。

应用层是为了粘合领域层与基础层,应用层不包括业务逻辑，领域层有具体业务逻辑


domain层会依赖于infrastructure层。但一个应用最核心的部分显然是domain层。
domain层依赖某种实现是不合适的，所以（可能）给予控制反转的思想，在domain 层定义了接口，
然后交由infrastructure来写。这样依赖关系就反转了，infrastructure依赖于domain定义的接口。


--------------------------------------------------------------------------------
不要用这版本，还在思考中
1 前台登录界面生成登录信息 loginInfoVO
2 后台web层接收生成的loginInfoVO传给应用服务层
3 后台应用服务层 调用领域服务
4 后台领域服务判断是否后台有这个用户 如果有比较密码
5 密码对了返回给前台RespModel

当有些时候业务逻辑不适合放在领域模型的时候就放在领域服务里
领域服务与领域模型两个可以放业务逻辑的地方，其他地方不要写业务逻辑
业务能放领域模型尽量放领域模型，实在不能放再考虑领域服务
--------------------------------------------------------------------------------

Yes - very good question. Like @Andrew Cooper, our team also went through all this.

We went with the following approaches (right or wrong):

Custom Membership Provider

Neither I or the other developer are fans of the built in ASP.NET Membership provider. It's way too bloated for what our site is about (simple, UGC-driven social website). We created a very simple one that does what our application needs, and nothing more. Whereas the built-in membership provider does everything you might need, but most likely won't.

Custom Forms Authentication Ticket/Authentication

Everything in our application uses interface-driven dependency injection (StructureMap). This includes Forms Authentication. We created a very thin interface:

public interface IAuthenticationService
{
   void SignIn(User user, HttpResponseBase httpResponseBase);
   void SignOut();
}
This simple interface allows easy mocking/testing. With the implementation, we create a custom forms authentication ticket containing: things like the UserId and the Roles, which are required on every HTTP request, do not frequently change and therefore should not be fetched on every request.

We then use an action filter to decrypt the forms authentication ticket (including the roles) and stick it in the HttpContext.Current.User.Identity (for which our Principal object is also interface-based).

Use of [Authorize] and [AdminOnly]

We can still make use of the authorization attributes in MVC. And we also created one for each role. [AdminOnly] simply checks the role for the current user, and throws a 401 (forbidden).

Simple, single table for User, simple POCO

All user information is stored in a single table (with the exception of "optional" user info, such as profile interests). This is mapped to a simple POCO (Entity Framework), which also has domain-logic built into the object.

User Repository/Service

Simple User Repository that is domain-specific. Things like changing password, updating profile, retrieving users, etc. The repository calls into domain logic on the User object i mentioned above. The service is a thin wrapper on top of the repository, which seperates single repository methods (e.g Find) into more specialized ones (FindById, FindByNickname).

Domain seperated from security

Our "domain" the User and his/her's association information. This includes name, profile, facebook/social integration, etc.

Things like "Login", "Logout" are dealing with authentication and things like "User.IsInRole" deals with authorization and therefore do not belong in the domain.

So our controllers work with both the IAuthenticationService and the IUserService.

Creating a profile is a perfect example of domain logic, that is mixed with authentication logic also.

Here's what our's looks like:

[HttpPost]
[ActionName("Signup")]
public ActionResult Signup(SignupViewModel model)
{
    if (ModelState.IsValid)
    {
        try
        {
            // Map to Domain Model.
            var user = Mapper.Map<SignupViewModel, Core.Entities.Users.User>(model);

            // Create salt and hash password.           
            user.Password = _authenticationService.SaltAndHashPassword();

            // Signup User.
            _userService.Save(user);

            // Save Changes.
            _unitOfWork.Commit();

            // Forms Authenticate this user.
            _authenticationService.SignIn(user, Response);

            // Redirect to homepage.
            return RedirectToAction("Index", "Home", new { area = "" });
        }
        catch (Exception exception)
        {
            ModelState.AddModelError("SignupError", "Sorry, an error occured during Signup. Please try again later.");
            _loggingService.Error(exception);
        }
    }

    return View(model);
}
Summary

The above has worked well for us. I love having a simple User table, and not that bloated madness that is the ASP.NET Membership provider. It's simple and represents our domain, not ASP.NET's representation of it.

That being said, as i said we have a simple website. If you're working on a banking website then i would be careful about re-inventing the wheel.

My advice to use is create your domain/model first, before you even think about authentication. (of course, this is what DDD is all about).

Then work out your security requirements and choose an authentication provider (off the shelf, or custom) appropriately.

Do not let ASP.NET dictate how your domain should be designed. This is the trap most people fall into (including me, on a previous project).

Good luck!

--------------------------------------------------------------------------------
Entity，value object, Aggregate
entity
entity是一类可识别的可追踪的对象。

说简单了，它必须有identifier，再简单点id（可识别，可被追踪）。

另外它是有可变对象，mutable。但即使状态变化了之后，entity还是原来的entity。（好绕口）

  现实一点的例子。一个人家“王帝”，他改名交了“王皇”，名字虽然变了，但还是同一人。
当然现实世界里我们很难去寻找一个identifier(识别码)，如何定义一个不变的identifier会是个哲学问题，
但编程时就简单多了，直接搞个id就就行。

value object
与entity对应的一个概念叫value object

它是一个值，是不可变的，immutable。没有identifier，也不需要被追踪！

  比如java中的字符串和value object的感念很相近。字符串生成之后就是不可变的。而且也没有什么id来识别它。

什么时候使用entity，什么时候使用value object

具体问题具体分析

比如我们需要对地址这个东西建模。如果我们关心的是地址的履历之类的信息，
过去30年前这个地址可能叫霞飞路，现在可能叫淮海路，而且需求是我们必须知道霞飞路，
淮海路指的是一个地址。那很可能我们需要的是entity。这个entity可能还要开发change()的方法来改变路名。

但如果我们做的是一个送货软件。地址只是表示一个目的地而已，
霞飞路和淮海路在我看来就是不同的，那就说明，
你不必对地址本身的变化进行追踪（送货地址变了，对你很重要。但霞飞路改名成淮海路对你不重要。）。
那value object就够了。

你可能觉得何必这么费事搞个表示地址的value object, 搞个字符串不就行了？
首先这不一定是一个关于ddd的问题。淡然很多情况下，我们可以的确用java的基础类来建模的。
但从面向对象的封装角度来说，我们可以考虑创造专门的类。
如果我们创建value object,它是可以拥有行为的。比如Address是一个value object。
它可以拥有getCountry(), getProvince(), getCity()等方法。


也就是说实体与值对象区别在于
1实体有唯一标识 值对象没有
2实体的状态是可以改变的，值对象的状态不会发生变化 
3实体因为唯一标识的原因可以被追踪，值对象不会被追踪

Aggregate
Aggregate，集合。是有多个（也可以是一个）entity，value object组成的对象。

Aggregate可以看作一个树状结构的东西。根是一个entity。
Aggregate的一个作用是保持domain object的关联性的正确。

Aggregate和Repository
Repository
Repository是用来存放一个aggregate的object。（是不是听起来像DAO？）

Repository的存在，让我们感觉我们存放在它里面的aggregate就好像on memory一样，
不必去关心它具体是和rdb对接还是其他的形式。

请注意的是Repository对应的是aggregate而不是entity！
虽然我们在实际偏码时不会去专门写aggregate的类，有关具体实现，之以后的文章会写。
简单地讲根entity就可以代表aggregate。

domain object的做法与active record的区别
active record pattern也是很常见的一种模式。大概是建立于数据表的一一映射的类，然后有各自的DAO类。乍看起来和domain object的做法是一样的。

1. 映射关系
active record一般以一个类对应一个数据表为前提
repository则没有这个限制。当一个aggregate需要对应多个数据表时，
那repository自然就对应多个数据表。repository隐藏了数据层的物理实现。
这里想多提一点。domain model的建立，称作理论设计比较合适。它尽量不关心物理的实现，只求对domain的正确反映。
而data model的设计，可以称作物理实现。是以数据永久化为目的。与ddd相关联，自然就是如何将domain object永久化。

2. domain object主张充血模式
active record常常会导致制造大量的于数据表对应的类，这些类一般不会有行为，而描述业务逻辑的职责就会到很多service类上。
domain object则希望类有自己的行为，而不是开放好多setter，让外部的类来控制自己的状态变化。

假设我们要实现一个账户管理的密码修改功能。

大致需求
账号通过邮箱地址来识别（identifier）
　- 密码不能为空

　- 密码必须加密（这个功能暂不实现）

修改密码

　- 修改密码时必须输入旧密码，旧密码输入正确后才可更改密码。

从aggregate开始
其实建模是一个过程，而且可能是程序设计里比较难有容易被忽略的过程。
就像很多侦探片里的推理一样，推理很难，但往往侦探片只会告诉你答案，而不是告诉你如何推理的。
很抱歉我这里也讲不了建模的过程，这回事另一个话题。但大概我们会想到如下的model。

Account aggregate
Account (entity, Account aggregate的root)
  因为密码可以更改可以理解为mutable，密码变化后，不代表账号就变成了另一个账号。所以把它定义成entity。
AccountId (value object)
  账号id生成后就不可变了。
Password (value object)
  密码设置后，密码本身是不可变的。
  更改账号密码应该理解为，用新密码换掉账号的旧密码。而非旧密码本身做了变化。
然后对应aggregate，会有AggregateRepository

具体的实现
Account

public class Account {
    private AccountId accountId;
    private EncryptedPassword encryptedPassword;
 
    public void changePassword(String oldPassword, String newPassword){
        if(encryptedPassword.verify(oldPassword)){
            throw new IllegalArgumentException("old encryptedPassword is not correct");
        }
        encryptedPassword = new EncryptedPassword(newPassword);
    }
 
    public static Account createAccount(String email, String password){
        Account account = new Account();
        account.accountId= new Account(email);
        account.encryptedPassword = new EncryptedPassword(password);
        return account;
    }
 
    private Account(){
 
    }
}


AccountId

@AllArgsConstructor
@Getter
public class AccountId {
    @NonNull
    private String email;
}
用来表示账号id的类。immutable。


EncyptedPassword

public class EncryptedPassword {
    private String encryptedPassword;
 
    public EncryptedPassword(@NonNull String password){
        if(password.equals("")){
            throw new IllegalArgumentException("password cannot be null");
        }
        // TODO password not encrypted.
        this.encryptedPassword = password;
    }
 
    public boolean verify(String ps){
        return encryptedPassword.equals(ps);
    }
}

密码不能为空的验证构造方法中。这在ddd的设计中始终比较常用的方法，在构造方法中做验证，避免矛盾（inconsisitency）的发生。
数据是否矛盾交给了类自己判断，因为只是类自己应该拥有的知识。当然，当验证逻辑变复杂后，可以把这部分逻辑放到外部专用的验证类。

IAccountRepository

public interface IAccountRepository {
    Account findById(String email);
 
    void save(Account account);
}

最后写一下application层的application service（之后的文章会对application service做说明）

AccountApplicationService

public class AccountApplicationService {
 
    @Autowired
    private IAccountRepository accountRepository;
 
    @Transactional
    public void changePassword(String email, String oldPassword, String newPasssord){
        Account account = accountRepository.findById(email);
        account.changePassword(oldPassword, newPassword);
        accountRepository.save(account);   
    }
}

其他说明
关于repository的实现
IAccountRepository的实现类没有写。这个会牵涉到具体的使用和中框架，orm啥的。
说一下比较令人烦恼的问题，是否该定义save()一个方法还是insert()，update()两个方法。
理想的来说save()是好的。因为domain就不用关系究竟是插入还是更新这种与db相关的操作。
然后当业务逻辑确实需要明确是登陆，还是更新时，insert()，update()会更方便。
这是个需要权衡的问题，感觉没有唯一解。
充血模型
可能大家也注意到，ddd的domain object都是采用充血模型的写法。以后也会写文章专门强调这一点。
value object真的有必要吗
AccountId真的有必要吗？直接一个String email吗？
EncryptedPassword真的有必要吗？
我承认，这些都存在讨论的空间。我也有可能是为了说明问题而使用了复杂的实现。

id类 vs String/Long
  如果id类都是Long或者String，那彼此之间是不能区别的。搞不清楚id究竟是哪个entity的id。
特意定义id类，可以在一些方法要传递好多id时防止一些认为错误。比如getAnObject(Long objAId, Long objBId)。
参数上objAId，objBId是不能搞错的。但如果数据类型都是Long，那编译器是核对不了的～
EncryptedPassword
  它有对密码进行核对的行为。这里提供了一种思路。当entity的逻辑过多，类变得过大时，
我们可以将一部分逻辑分到value object中。当然我们也可以在建模的时候就先考虑把一些逻辑放进value object中。
这也是domain-driven design一书错推崇的（没记错的话～）。

实际开发过程中应当避免使用Lombok这样的简化插件，因为降低了代码可读性,阻碍了团队项目环境可移植性。


ddd中的service
首先这个在这篇文章里讨论的service基于一个前提，就是采用view, application, domain, infrastructure的分层架构。ddd提倡的架构有很多种，大家可以看前面的文章。《domain driven design》原书也是基于分层架构来论述的。至于现在流行的洋葱架构该怎么办，有机会再讲吧～
ddd中有三种service。分别是application service, domain service, infrastructure service。

application service
首先从简单的开始讲。application service是应用程序的某个功能的入口（end point）。如果你使用的是分层架构，那它是位于presentation和domain之间。
我们想像我们要写一个api用来注册账号。
url: api/accounts
method: post
如果我们使用springMVC来实现这个api的话，那Controller会调用AccountApplicationService。

@RestController
@RequestMapping("api/accounts")
public class AccountController{
  @Autowired
  private AccountApplicationService accountApplicationService;

  @RequestMapping(value ="", method = RequestMthod.POST)
  public void register(@RequestBody AccountDTO accountDTO){
    accountApplicationService.register(accountDTO);
  }
}
上面的代码，controller讲画面传过来的dto传给了AccountApplicationService。
AccountApplicationService再来调用各种domain object。比如Account (entity), AccountRepository。

public class AccountApplicationService {
    @Autowired
    private IAccountRepository accountRepository;

    public void register(AccountDTO accountDTO){
        Account account = Account.createAccount(accountDTO.getEmail(), accountDTO.getPassword());
        accountRepository.save(account);
    }
}
infrastructure service
infrastructure service实现不依赖于业务(domain)的功能。简单的例子来讲，比如打印日志（log），发送邮件（如果你的应用软件不是处理邮件问题的话）
infrastructure service位于最底层的infrastructure层。

domain service
实现domain的service类。三种service中，唯一可以写业务逻辑的地方。
由于ddd提倡充血模型的缘故，我们在建模的时候要尽量避免制造domain service。尽量把业务逻辑放到其他的domain object中（比如entity, value object中）。

Service的比较
application service vs domain service
我想infrastructure是没有什么值得讨论的。而application service与domain service会是让人纠结的一个话题。
最近看到了clean architecture的设计后，感觉可能稍微容易解释一些。(对不起，说好用只讨论分层架构的，却又提起了clean architecture，因为好难解释…)

entities的部分对应的便是domain部分。
而application service对应的是use cases 用例。
相比于application service这个有点不知所云的名次，用例是不是更容易理解一些了（也许不是。。。）？
用例
用uml图来画的话，就是下面这样的东西。

用例具体教科书般的定义，大家可以自行谷歌一下。大致就是描述一个系统大致的功能而并不描述具体内部的结构或者设计。
那在clean architecture中，domain object的操作必须通过「用例」这个入口。

那在操作层面上如何处理application service和domain service呢？

首先application service既然是入口，在一个模块中，它必定是存在的。与之相反，domain service则不一定需要。
因此，再做类设计时可以先假定domain service不存在。直接写application service，在application service中对其他domain object进行操作。
理想情况下，application service存在的代码基本上就是它调用其他domain object的方法，具体的业务逻辑都会在domain object的方法中。所以当application service中出现if/else之类的语句，或者application service的一个方法变得很长时，我们就该警惕是不是把业务逻辑写到了application service中。这个时候我们该考虑是否需要重构，比如把逻辑放进domain object，或者增加一个domain service。
按上面一个注册账号的例子，这个时候我们并不需要domain service。
但如果我们首先要确认email是否被注册，那这时候代码就会变成下面那样

public class AccountApplicationService {

    @Autowired
    private IAccountRepository accountRepository;

    public void register(AccountDTO accountDTO){
        Account account = accountRepository.find(new AccountSpecificationByEmail(accountDTO.getEmail()));
        if (account != null) {
            throw new EmailAlreadyRegisteredException();
        }
        account = Account.createAccount(accountDTO.getEmail(), accountDTO.getPassword());
        accountRepository.save(account);
    }

}
尽管方法不是很长，但判断账号能否被注册的逻辑（业务逻辑）写在了application service中。我们必须考虑将这个逻辑移到其他地方。
当然理想情况下是把它放进Account中，但查询账号是否存在的逻辑使用到AccountRepository，这个很难放进Account中，所以AccountService自然会是一个选择。

public class AccountService {

    @Autowired
    private IAccountRepository accountRepository;

    public void register(String email, String password){
        Account account = accountRepository.find(new AccountSpecificationByEmail(email));
        if (account != null) {
            throw new EmailAlreadyRegisteredException();
        }
        account = Account.createAccount(email, password);
        accountRepository.save(account);
    }
}
因为不想让domain层的东西依赖于application层的form，dto类，所以方法的参数没有用dto。
那application service会变成

public class AccountApplicationService {

    @Autowired
    private AccountService accountService;

    public void register(AccountDTO accountDTO){
        accountService.register(accountDTO.getEmail(), accountDTO.getPassword());
    }

}
另外，有了AccountService这个类，并不是所有关于Account的逻辑都必须放进那里。
比如AccountApplicationService里的changePassword()，没有必要放进AccountService中。

public class AccountApplicationService {

    @Autowired
    private IAccountRepository accountRepository;
    @Autowired
    private AccountService accountService;

    public void register(AccountDTO accountDTO){
        accountService.register(accountDTO.getEmail(), accountDTO.getPassword());
    }

    public void changePassword(String email, String oldPassword, String newPasssord) {
        Account account = accountRepository.findById(email);
        account.changePassword(oldPassword, newPasssord);
        accountRepository.save(account);
    }

}
总结
ddd中把service类分成三种。
application service, domain service, infrastructure service。
domain service中可以写业务逻辑，但同时理想情况下我们尽量不实用domain service。
另外，我们要注意不要讲业务逻辑写到application service中
--------------------------------------------------------------------------------

unit of work

你家来客人了，要泡茶。
一共几件事
1、烧开水  
2、拿茶叶
3、洗茶壶、茶杯
4、倒茶
UOW就是泡茶（包含上面那几件事）

也就是一个事务的控制过程
开启事务
持久化对象1
更新对象2
删除对象3
提交事务

从开始事务到提交事务的操作远程是一个工作单元，这样可以保证数据完整性
