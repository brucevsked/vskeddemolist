
软件的本质在于解决业务问题，以辅助业务而生存。
公司的业务创建的利润，所以合理解决业务问题才是关键。
这里的业务就是指一种领域
每一种业务都会涉及到一种知识体系，软件就是将这个知识体系表达出来。
--------------------------------------------------------------------------------
3个基本用途决定模型选择
1 模型和设计核心互相影响
2 模型是团队所有成员使用通用语言的中枢
3 模型是浓缩的知识
--------------------------------------------------------------------------------
有效建模的要素
1 模型和实现的绑定
2 建立了一种基于模型的语言
3 开发一个蕴含丰富知识的模型
4 提炼模型
5 头脑风暴和实验
--------------------------------------------------------------------------------
规则类的处理可以使用策略模式来解决
要找出模型中隐藏概念（如允许超订10%）
示例代码允许 10%超订
原始代码
public int makeBooking(Cargo cargo,Voyage voyage){
  double maxBooking=voyage.capacity()*1.1;
  if((voyage.bookedCargoSize()+cargo.size())>maxBooking)
      return -1;
  int confirmation=orderConfirmationSequence.next();
  voyage.addCargo(cargo,confirmation);
  return confirmation;
}

修改后代码，把这条规则抽象出来
public boolean isAllowed(Cargo cargo,Voyage voyage){
  return (cargo.size()+voyage.bookedCargoSize())<=
            (voyage.capacity()*1.1);
}

public int makeBooking(Cargo cargo,Voyage voyage){
  if(!overbookingpolicy.isAllowed(cargo,voyage))
      return -1;
  int confirmation=orderConfirmationSequence.next();
  voyage.addCargo(cargo,confirmation);
  return confirmation;
}
--------------------------------------------------------------------------------

模式 Ubiquitous Language统一语言
一个团队 一个项目 一种语言
将交流需求中用到的词语写到一个专门的文档中
词汇包括类与主要操作的名称
并不断更新这个文档中的词语与意思
每一个词语不应当有歧义，需要精确描述
对统一语言的修改就是对领域模型的修改

--------------------------------------------------------------------------------
模式 Model-Driven Design 领域驱动设计
两个基本要素
即模型要支持有效的实现
抽象出关键的领域知识

抽象类Abstract Net
抽象类实现类Net
抽象类实现类Bus
类Layout Rule

业务流程
1创建连线a0
Net a0 =new Net("a0);
2创建连线a1
Net a1 =new Net("a1);
3创建总线a
Bus a=new Bus("a");
4总线连接线a0
a.addNet(a0);
5总线连接线a1
a.addNet(a1);
6创建连线规则
NetRule minWidth4=NetRule.create(MIN_WIDTH,4);
7为总线绑定连线规则
a.assignRule(minWidth4);

abstract class AbstractNet{
  private Set rules;
  void assignRule(LayoutRule rule){
    rules.add(rule);
  }

 Set assignedRules(){
    return rules;
  }
}

class Net extends AbstractNet{
  private Bus bus;

  Set assignedRules(){
    Set result=new HashSet();
    result.addAll(super.assignedRules());
    result.addAll(bus.assignedRules());
    return result;
  }
}

服务列表
服务                  |职责
Net List import |读取Net列表文件，将每一行数据创建Net实例
Net Rule export|已知Net集合，将所有附加规则写入规则文件
Bus Repository |提供通过名称访问Bus（总线）的接口

工具类列表
类名                         |职责
Net Repository         |提供通过名称访问Net的接口
Inferred Bus Factory |已经Net集合，利用命名约定来推断总线，并且创建总线实例

现在，启动应用程序，用导入数据来初始化Net和Bus仓库。
Collection nets=NetListImportService.read(aFile);
NetRepository.addAll(nets);
Collection buses=InferredBusFactory.groupIntoBuses(nets);
BusRepository.addAll(buses);
--------------------------------------------------------------------------------
模式 Hands-On Modeler 亲身实践的建模者
--------------------------------------------------------------------------------
模式 Layered Architecture 分层架构
*用户界面层（或表示层）负责向用户显示信息和解释用户指令
这里的用户可以是另一个计算机系统，不一定是使用用户界面的人
*应用层 定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题。
这一层所负责的工作对业务来说意义重大，
也是与其他系统的应用层进行交互的必要渠道。
应用层要尽量简单，不包含业务规则或者知识，只为下一层中的领域对象协调任务，
分配工作使他们互相协作。它没有反映业务情况的状态，但可以具有另外一种状态，
为用户或程序显示某个任务的进度
*领域层（或模型层） 负责表达业务概念，业务状态信息以及业务规则。
尽管保存业务状态的技术细节是由基础设施层实现的，
但是反映业务情况的状态是由本层控制并且使用的。
领域层是业务软件的核心
*基础设施层 为上面各层提供通用的技术能力：为应用层传递消息，
为领域层提供持久化机制，
为用户界面层绘制屏幕组件，等等。
基础设施层还能够通过架构框架来支持4个层次间的交互模式
网上银行分层示例
用户界面层 transferController
应用层 fundsTransferService
领域层 a123:Account,a234:Account 两个账户对象
基础设施层 unit of work manager(事务处理与持久化JPA),O-R Mapper(持久化对象模型DTO)

流程说明
1. transferController->tranfer(a123,a234,100) 要转账
控制层调用转账方法，传入要转账的两个账户与转账金额，三个参数源账户，目标账户，转账金额
2. FundsTransferService-beginTransaction()->Unit of Work Manager 开启事务
应用层调用基础设施层的持久化单元开启事务
3. FundsTransferService-transferTo(a234,100)->a123:Account 领域模型Account实例a123
应用层调用本层的转账方法此方法会通知领域层a123领域模型要向a234领域模型转100
4. a123:Account -credit(100)->a234:Account 领域模型Account实例a234
领域层a123领域模型授信给a234领域模型100
5. a234:Account -addToUnitOfWork(a234)->Unit of Work Manager
领域层a234领域模型通知基础层持久化单元（注意这时候并没真正存储到库里）
6. a234:Account-confirm->a123:account
领域层a234确认收到a123信用100
7. a123:Account-debit(100)-a123
领域层a123领域模型自己记账100
8. a123:Account-addToUnitOfWork(a123)->Unit of Work Manager
领域层a123领域模型通知基础层持久化单元（注意这时候并没真正存储到库里）
9. a123:Account-confirm->FundsTransferService
领域层模型通知应用层服务这活确认搞完了
10. FundsTransferService-commit()->Unit of Work Manager
应用层服务通知基础层持久化单元你可以真正持久化到数据库了
11.Unit of WorkManager -update(collection)->O-R Mapper
基础层通过持久化模型将刚才改好的两个领域模型转换为关系数据库模型保存到库

--------------------------------------------------------------------------------
模式 Entity(Reference Objecct) 实体（引用对象）

--------------------------------------------------------------------------------
模式 Value Object 值对象（描述对象）

--------------------------------------------------------------------------------
模式  Service 服务

--------------------------------------------------------------------------------
模式 Module(Package) 模块(包）

--------------------------------------------------------------------------------
模式 Aggregate 聚合
--------------------------------------------------------------------------------
模式 Factory 工厂
--------------------------------------------------------------------------------
模式 Repository 仓库
--------------------------------------------------------------------------------
模式 Intention-Revealing Interfaces 释意接口
--------------------------------------------------------------------------------
模式 Side-Effect-Free function 无副作用的函数
--------------------------------------------------------------------------------
模式 Assertion 断言
--------------------------------------------------------------------------------
模式 Conceptual Contour 概念轮廓
--------------------------------------------------------------------------------
模式 Standalone Class 单例类
--------------------------------------------------------------------------------
模式 Closure of Operation 操作结束
--------------------------------------------------------------------------------
模式 Strategy(Policy) 策略
--------------------------------------------------------------------------------
模式 Composite 组合
--------------------------------------------------------------------------------
模式 Bounded Context
--------------------------------------------------------------------------------
模式 Continuous Integration
--------------------------------------------------------------------------------
模式 Context Map
--------------------------------------------------------------------------------
模式 Shared Kernel
--------------------------------------------------------------------------------
模式 Customer/Supplier Development Team
--------------------------------------------------------------------------------
模式 Conformist
--------------------------------------------------------------------------------
模式 Anticorruption Layer
--------------------------------------------------------------------------------
模式 Separate Way
--------------------------------------------------------------------------------
模式 Open Host Service
--------------------------------------------------------------------------------
模式 Published Language
--------------------------------------------------------------------------------
模式 Core Domain
--------------------------------------------------------------------------------
模式 Generic Subdomain
--------------------------------------------------------------------------------
模式 Domain Vision Statement
--------------------------------------------------------------------------------
模式 Highlighted Core
--------------------------------------------------------------------------------
模式 Cohesive Mechanism
--------------------------------------------------------------------------------
模式 Segregated Core
--------------------------------------------------------------------------------
模式 Abstract Core
--------------------------------------------------------------------------------
模式 Evolving Order
--------------------------------------------------------------------------------
模式 System Metaphor
--------------------------------------------------------------------------------
模式 Responsibility Layer
--------------------------------------------------------------------------------
模式 Knowledge Level
--------------------------------------------------------------------------------
模式 Pluggable Component Framework
--------------------------------------------------------------------------------







--------------------------------------------------------------------------------
模型都有哪些
视图模型VO 封装前端请求数据为对象
领域模型DM 收到对象并进行实际业务处理
数据模型DTO 将处理完成的结果领域模型转换为数据模型


--------------------------------------------------------------------------------
取款分层示例
应用层
public class TransactionApplicationService{
  @Autowired
  private IAccountRepository accountRepository;  
  public void withdraw(AccountId accountId, Integer amount){  
    Account account = accountRepository.find(new AccountSpecificationById(accountId)); // 找到用户账户
    account.withdraw(amount);  // 取款
    accountRepository.save(account);  // 保存账户状态
  }
}
领域层
private AccountId accountId;
  private Integer balance;
  
  public void withdraw(amount){
    if(balance < amount){
      throw new IllegalStateException("balance is not enough");  // 余额不够就不能取款
    }
    balance = balance - amount;
  }
}

TransactionApplication属于application层。

Account，IAccountRepository这些类属于domain层。

infrastructure里会有IAccountRepository的具体实现，这里没有写

请注意取款的具体逻辑是在Account类里的。如余额够不够，和金额的具体计算（虽然很简单）。
所以业务逻辑是在domain层。

TransactionApplication只是把具体的domain object找到，调用其开放的接口，不涉及具体逻辑。
上边的例子找到用户的账户，告诉账户对象扣钱（具体怎么扣不管），保存账户的状态。

应用层是为了粘合领域层与基础层,应用层不包括业务逻辑，领域层有具体业务逻辑


domain层会依赖于infrastructure层。但一个应用最核心的部分显然是domain层。
domain层依赖某种实现是不合适的，所以（可能）给予控制反转的思想，在domain 层定义了接口，
然后交由infrastructure来写。这样依赖关系就反转了，infrastructure依赖于domain定义的接口。


--------------------------------------------------------------------------------
不要用这版本，还在思考中
1 前台登录界面生成登录信息 loginInfoVO
2 后台web层接收生成的loginInfoVO传给应用服务层
3 后台应用服务层 调用领域服务
4 后台领域服务判断是否后台有这个用户 如果有比较密码
5 密码对了返回给前台RespModel

当有些时候业务逻辑不适合放在领域模型的时候就放在领域服务里
领域服务与领域模型两个可以放业务逻辑的地方，其他地方不要写业务逻辑
业务能放领域模型尽量放领域模型，实在不能放再考虑领域服务
--------------------------------------------------------------------------------

Yes - very good question. Like @Andrew Cooper, our team also went through all this.

We went with the following approaches (right or wrong):

Custom Membership Provider

Neither I or the other developer are fans of the built in ASP.NET Membership provider. It's way too bloated for what our site is about (simple, UGC-driven social website). We created a very simple one that does what our application needs, and nothing more. Whereas the built-in membership provider does everything you might need, but most likely won't.

Custom Forms Authentication Ticket/Authentication

Everything in our application uses interface-driven dependency injection (StructureMap). This includes Forms Authentication. We created a very thin interface:

public interface IAuthenticationService
{
   void SignIn(User user, HttpResponseBase httpResponseBase);
   void SignOut();
}
This simple interface allows easy mocking/testing. With the implementation, we create a custom forms authentication ticket containing: things like the UserId and the Roles, which are required on every HTTP request, do not frequently change and therefore should not be fetched on every request.

We then use an action filter to decrypt the forms authentication ticket (including the roles) and stick it in the HttpContext.Current.User.Identity (for which our Principal object is also interface-based).

Use of [Authorize] and [AdminOnly]

We can still make use of the authorization attributes in MVC. And we also created one for each role. [AdminOnly] simply checks the role for the current user, and throws a 401 (forbidden).

Simple, single table for User, simple POCO

All user information is stored in a single table (with the exception of "optional" user info, such as profile interests). This is mapped to a simple POCO (Entity Framework), which also has domain-logic built into the object.

User Repository/Service

Simple User Repository that is domain-specific. Things like changing password, updating profile, retrieving users, etc. The repository calls into domain logic on the User object i mentioned above. The service is a thin wrapper on top of the repository, which seperates single repository methods (e.g Find) into more specialized ones (FindById, FindByNickname).

Domain seperated from security

Our "domain" the User and his/her's association information. This includes name, profile, facebook/social integration, etc.

Things like "Login", "Logout" are dealing with authentication and things like "User.IsInRole" deals with authorization and therefore do not belong in the domain.

So our controllers work with both the IAuthenticationService and the IUserService.

Creating a profile is a perfect example of domain logic, that is mixed with authentication logic also.

Here's what our's looks like:

[HttpPost]
[ActionName("Signup")]
public ActionResult Signup(SignupViewModel model)
{
    if (ModelState.IsValid)
    {
        try
        {
            // Map to Domain Model.
            var user = Mapper.Map<SignupViewModel, Core.Entities.Users.User>(model);

            // Create salt and hash password.           
            user.Password = _authenticationService.SaltAndHashPassword();

            // Signup User.
            _userService.Save(user);

            // Save Changes.
            _unitOfWork.Commit();

            // Forms Authenticate this user.
            _authenticationService.SignIn(user, Response);

            // Redirect to homepage.
            return RedirectToAction("Index", "Home", new { area = "" });
        }
        catch (Exception exception)
        {
            ModelState.AddModelError("SignupError", "Sorry, an error occured during Signup. Please try again later.");
            _loggingService.Error(exception);
        }
    }

    return View(model);
}
Summary

The above has worked well for us. I love having a simple User table, and not that bloated madness that is the ASP.NET Membership provider. It's simple and represents our domain, not ASP.NET's representation of it.

That being said, as i said we have a simple website. If you're working on a banking website then i would be careful about re-inventing the wheel.

My advice to use is create your domain/model first, before you even think about authentication. (of course, this is what DDD is all about).

Then work out your security requirements and choose an authentication provider (off the shelf, or custom) appropriately.

Do not let ASP.NET dictate how your domain should be designed. This is the trap most people fall into (including me, on a previous project).

Good luck!

--------------------------------------------------------------------------------
Entity，value object, Aggregate
entity
entity是一类可识别的可追踪的对象。

说简单了，它必须有identifier，再简单点id（可识别，可被追踪）。

另外它是有可变对象，mutable。但即使状态变化了之后，entity还是原来的entity。（好绕口）

  现实一点的例子。一个人家“王帝”，他改名交了“王皇”，名字虽然变了，但还是同一人。
当然现实世界里我们很难去寻找一个identifier(识别码)，如何定义一个不变的identifier会是个哲学问题，
但编程时就简单多了，直接搞个id就就行。

value object
与entity对应的一个概念叫value object

它是一个值，是不可变的，immutable。没有identifier，也不需要被追踪！

  比如java中的字符串和value object的感念很相近。字符串生成之后就是不可变的。而且也没有什么id来识别它。

什么时候使用entity，什么时候使用value object

具体问题具体分析

比如我们需要对地址这个东西建模。如果我们关心的是地址的履历之类的信息，
过去30年前这个地址可能叫霞飞路，现在可能叫淮海路，而且需求是我们必须知道霞飞路，
淮海路指的是一个地址。那很可能我们需要的是entity。这个entity可能还要开发change()的方法来改变路名。

但如果我们做的是一个送货软件。地址只是表示一个目的地而已，
霞飞路和淮海路在我看来就是不同的，那就说明，
你不必对地址本身的变化进行追踪（送货地址变了，对你很重要。但霞飞路改名成淮海路对你不重要。）。
那value object就够了。

你可能觉得何必这么费事搞个表示地址的value object, 搞个字符串不就行了？
首先这不一定是一个关于ddd的问题。淡然很多情况下，我们可以的确用java的基础类来建模的。
但从面向对象的封装角度来说，我们可以考虑创造专门的类。
如果我们创建value object,它是可以拥有行为的。比如Address是一个value object。
它可以拥有getCountry(), getProvince(), getCity()等方法。


也就是说实体与值对象区别在于
1实体有唯一标识 值对象没有
2实体的状态是可以改变的，值对象的状态不会发生变化 
3实体因为唯一标识的原因可以被追踪，值对象不会被追踪

Aggregate
Aggregate，集合。是有多个（也可以是一个）entity，value object组成的对象。

Aggregate可以看作一个树状结构的东西。根是一个entity。
Aggregate的一个作用是保持domain object的关联性的正确。

Aggregate和Repository
Repository
Repository是用来存放一个aggregate的object。（是不是听起来像DAO？）

Repository的存在，让我们感觉我们存放在它里面的aggregate就好像on memory一样，
不必去关心它具体是和rdb对接还是其他的形式。

请注意的是Repository对应的是aggregate而不是entity！
虽然我们在实际偏码时不会去专门写aggregate的类，有关具体实现，之以后的文章会写。
简单地讲根entity就可以代表aggregate。

domain object的做法与active record的区别
active record pattern也是很常见的一种模式。大概是建立于数据表的一一映射的类，然后有各自的DAO类。乍看起来和domain object的做法是一样的。

1. 映射关系
active record一般以一个类对应一个数据表为前提
repository则没有这个限制。当一个aggregate需要对应多个数据表时，
那repository自然就对应多个数据表。repository隐藏了数据层的物理实现。
这里想多提一点。domain model的建立，称作理论设计比较合适。它尽量不关心物理的实现，只求对domain的正确反映。
而data model的设计，可以称作物理实现。是以数据永久化为目的。与ddd相关联，自然就是如何将domain object永久化。

2. domain object主张充血模式
active record常常会导致制造大量的于数据表对应的类，这些类一般不会有行为，而描述业务逻辑的职责就会到很多service类上。
domain object则希望类有自己的行为，而不是开放好多setter，让外部的类来控制自己的状态变化。

假设我们要实现一个账户管理的密码修改功能。

大致需求
账号通过邮箱地址来识别（identifier）
　- 密码不能为空

　- 密码必须加密（这个功能暂不实现）

修改密码

　- 修改密码时必须输入旧密码，旧密码输入正确后才可更改密码。

从aggregate开始
其实建模是一个过程，而且可能是程序设计里比较难有容易被忽略的过程。
就像很多侦探片里的推理一样，推理很难，但往往侦探片只会告诉你答案，而不是告诉你如何推理的。
很抱歉我这里也讲不了建模的过程，这回事另一个话题。但大概我们会想到如下的model。

Account aggregate
Account (entity, Account aggregate的root)
  因为密码可以更改可以理解为mutable，密码变化后，不代表账号就变成了另一个账号。所以把它定义成entity。
AccountId (value object)
  账号id生成后就不可变了。
Password (value object)
  密码设置后，密码本身是不可变的。
  更改账号密码应该理解为，用新密码换掉账号的旧密码。而非旧密码本身做了变化。
然后对应aggregate，会有AggregateRepository

具体的实现
Account

public class Account {
    private AccountId accountId;
    private EncryptedPassword encryptedPassword;
 
    public void changePassword(String oldPassword, String newPassword){
        if(encryptedPassword.verify(oldPassword)){
            throw new IllegalArgumentException("old encryptedPassword is not correct");
        }
        encryptedPassword = new EncryptedPassword(newPassword);
    }
 
    public static Account createAccount(String email, String password){
        Account account = new Account();
        account.accountId= new Account(email);
        account.encryptedPassword = new EncryptedPassword(password);
        return account;
    }
 
    private Account(){
 
    }
}


AccountId

@AllArgsConstructor
@Getter
public class AccountId {
    @NonNull
    private String email;
}
用来表示账号id的类。immutable。


EncyptedPassword

public class EncryptedPassword {
    private String encryptedPassword;
 
    public EncryptedPassword(@NonNull String password){
        if(password.equals("")){
            throw new IllegalArgumentException("password cannot be null");
        }
        // TODO password not encrypted.
        this.encryptedPassword = password;
    }
 
    public boolean verify(String ps){
        return encryptedPassword.equals(ps);
    }
}

密码不能为空的验证构造方法中。这在ddd的设计中始终比较常用的方法，在构造方法中做验证，避免矛盾（inconsisitency）的发生。
数据是否矛盾交给了类自己判断，因为只是类自己应该拥有的知识。当然，当验证逻辑变复杂后，可以把这部分逻辑放到外部专用的验证类。

IAccountRepository

public interface IAccountRepository {
    Account findById(String email);
 
    void save(Account account);
}

最后写一下application层的application service（之后的文章会对application service做说明）

AccountApplicationService

public class AccountApplicationService {
 
    @Autowired
    private IAccountRepository accountRepository;
 
    @Transactional
    public void changePassword(String email, String oldPassword, String newPasssord){
        Account account = accountRepository.findById(email);
        account.changePassword(oldPassword, newPassword);
        accountRepository.save(account);   
    }
}

其他说明
关于repository的实现
IAccountRepository的实现类没有写。这个会牵涉到具体的使用和中框架，orm啥的。
说一下比较令人烦恼的问题，是否该定义save()一个方法还是insert()，update()两个方法。
理想的来说save()是好的。因为domain就不用关系究竟是插入还是更新这种与db相关的操作。
然后当业务逻辑确实需要明确是登陆，还是更新时，insert()，update()会更方便。
这是个需要权衡的问题，感觉没有唯一解。
充血模型
可能大家也注意到，ddd的domain object都是采用充血模型的写法。以后也会写文章专门强调这一点。
value object真的有必要吗
AccountId真的有必要吗？直接一个String email吗？
EncryptedPassword真的有必要吗？
我承认，这些都存在讨论的空间。我也有可能是为了说明问题而使用了复杂的实现。

id类 vs String/Long
  如果id类都是Long或者String，那彼此之间是不能区别的。搞不清楚id究竟是哪个entity的id。
特意定义id类，可以在一些方法要传递好多id时防止一些认为错误。比如getAnObject(Long objAId, Long objBId)。
参数上objAId，objBId是不能搞错的。但如果数据类型都是Long，那编译器是核对不了的～
EncryptedPassword
  它有对密码进行核对的行为。这里提供了一种思路。当entity的逻辑过多，类变得过大时，
我们可以将一部分逻辑分到value object中。当然我们也可以在建模的时候就先考虑把一些逻辑放进value object中。
这也是domain-driven design一书错推崇的（没记错的话～）。

实际开发过程中应当避免使用Lombok这样的简化插件，因为降低了代码可读性,阻碍了团队项目环境可移植性。


ddd中的service
首先这个在这篇文章里讨论的service基于一个前提，就是采用view, application, domain, infrastructure的分层架构。ddd提倡的架构有很多种，大家可以看前面的文章。《domain driven design》原书也是基于分层架构来论述的。至于现在流行的洋葱架构该怎么办，有机会再讲吧～
ddd中有三种service。分别是application service, domain service, infrastructure service。

application service
首先从简单的开始讲。application service是应用程序的某个功能的入口（end point）。如果你使用的是分层架构，那它是位于presentation和domain之间。
我们想像我们要写一个api用来注册账号。
url: api/accounts
method: post
如果我们使用springMVC来实现这个api的话，那Controller会调用AccountApplicationService。

@RestController
@RequestMapping("api/accounts")
public class AccountController{
  @Autowired
  private AccountApplicationService accountApplicationService;

  @RequestMapping(value ="", method = RequestMthod.POST)
  public void register(@RequestBody AccountDTO accountDTO){
    accountApplicationService.register(accountDTO);
  }
}
上面的代码，controller讲画面传过来的dto传给了AccountApplicationService。
AccountApplicationService再来调用各种domain object。比如Account (entity), AccountRepository。

public class AccountApplicationService {
    @Autowired
    private IAccountRepository accountRepository;

    public void register(AccountDTO accountDTO){
        Account account = Account.createAccount(accountDTO.getEmail(), accountDTO.getPassword());
        accountRepository.save(account);
    }
}
infrastructure service
infrastructure service实现不依赖于业务(domain)的功能。简单的例子来讲，比如打印日志（log），发送邮件（如果你的应用软件不是处理邮件问题的话）
infrastructure service位于最底层的infrastructure层。

domain service
实现domain的service类。三种service中，唯一可以写业务逻辑的地方。
由于ddd提倡充血模型的缘故，我们在建模的时候要尽量避免制造domain service。尽量把业务逻辑放到其他的domain object中（比如entity, value object中）。

Service的比较
application service vs domain service
我想infrastructure是没有什么值得讨论的。而application service与domain service会是让人纠结的一个话题。
最近看到了clean architecture的设计后，感觉可能稍微容易解释一些。(对不起，说好用只讨论分层架构的，却又提起了clean architecture，因为好难解释…)

entities的部分对应的便是domain部分。
而application service对应的是use cases 用例。
相比于application service这个有点不知所云的名次，用例是不是更容易理解一些了（也许不是。。。）？
用例
用uml图来画的话，就是下面这样的东西。

用例具体教科书般的定义，大家可以自行谷歌一下。大致就是描述一个系统大致的功能而并不描述具体内部的结构或者设计。
那在clean architecture中，domain object的操作必须通过「用例」这个入口。

那在操作层面上如何处理application service和domain service呢？

首先application service既然是入口，在一个模块中，它必定是存在的。与之相反，domain service则不一定需要。
因此，再做类设计时可以先假定domain service不存在。直接写application service，在application service中对其他domain object进行操作。
理想情况下，application service存在的代码基本上就是它调用其他domain object的方法，具体的业务逻辑都会在domain object的方法中。所以当application service中出现if/else之类的语句，或者application service的一个方法变得很长时，我们就该警惕是不是把业务逻辑写到了application service中。这个时候我们该考虑是否需要重构，比如把逻辑放进domain object，或者增加一个domain service。
按上面一个注册账号的例子，这个时候我们并不需要domain service。
但如果我们首先要确认email是否被注册，那这时候代码就会变成下面那样

public class AccountApplicationService {

    @Autowired
    private IAccountRepository accountRepository;

    public void register(AccountDTO accountDTO){
        Account account = accountRepository.find(new AccountSpecificationByEmail(accountDTO.getEmail()));
        if (account != null) {
            throw new EmailAlreadyRegisteredException();
        }
        account = Account.createAccount(accountDTO.getEmail(), accountDTO.getPassword());
        accountRepository.save(account);
    }

}
尽管方法不是很长，但判断账号能否被注册的逻辑（业务逻辑）写在了application service中。我们必须考虑将这个逻辑移到其他地方。
当然理想情况下是把它放进Account中，但查询账号是否存在的逻辑使用到AccountRepository，这个很难放进Account中，所以AccountService自然会是一个选择。

public class AccountService {

    @Autowired
    private IAccountRepository accountRepository;

    public void register(String email, String password){
        Account account = accountRepository.find(new AccountSpecificationByEmail(email));
        if (account != null) {
            throw new EmailAlreadyRegisteredException();
        }
        account = Account.createAccount(email, password);
        accountRepository.save(account);
    }
}
因为不想让domain层的东西依赖于application层的form，dto类，所以方法的参数没有用dto。
那application service会变成

public class AccountApplicationService {

    @Autowired
    private AccountService accountService;

    public void register(AccountDTO accountDTO){
        accountService.register(accountDTO.getEmail(), accountDTO.getPassword());
    }

}
另外，有了AccountService这个类，并不是所有关于Account的逻辑都必须放进那里。
比如AccountApplicationService里的changePassword()，没有必要放进AccountService中。

public class AccountApplicationService {

    @Autowired
    private IAccountRepository accountRepository;
    @Autowired
    private AccountService accountService;

    public void register(AccountDTO accountDTO){
        accountService.register(accountDTO.getEmail(), accountDTO.getPassword());
    }

    public void changePassword(String email, String oldPassword, String newPasssord) {
        Account account = accountRepository.findById(email);
        account.changePassword(oldPassword, newPasssord);
        accountRepository.save(account);
    }

}
总结
ddd中把service类分成三种。
application service, domain service, infrastructure service。
domain service中可以写业务逻辑，但同时理想情况下我们尽量不实用domain service。
另外，我们要注意不要讲业务逻辑写到application service中

之前的文章中讲到了entity, value object, repository等domain object。这次终于能将一些相对比较轻松的话题了

Factory
这个设计模式中应该有一个叫工厂模式，ddd可能也是借鉴了它。
ddd比较注重数据的完整性。
有关数据完整性，百度了一下，结果

存储在数据库中的所有数据值均正确的状态

复习一下，ddd中有aggregate（集合）这个概念，集合中的entity, value有一定的必须保持恒定不变的状态。
而ddd中的数据完整性指的就是这中概念。
比如有一个aggregate叫Person。其中有两条腿Leg(ValueObject)

public class Person {
  List<Leg> legs;
}

那数据完整性观点来讲，无论我们调用什么方法，绝对不能出现下面这种情况

legs.size() != 2

另外ddd提倡充血模式。所以比如说我们创建一个entity的类之后，不会再调用一大堆setter来初始化。
entity被创建了，它的状态时必须是符合业务逻辑要求，而不是需要进一步加工的。听起来很绕口。来说个实际例子吧。
比如我们要做一个购物网站，需要一个商品的类。Commodity。下面的贫血模型是ddd所反对的。

@Setter
@Getter
public class Commodity{

  private CommodityId id;
  private Category category;
  private String commodityName;
  private String description;
  private Date dateCreated;
  private Double price;

  ...

}

所以一般情况，自然我们必须在构造方法中对类进行初始化（原本很自然而然的做法，
构造方法当然是来构造类的，但因为贫血模型的流行，用含参数的构造方法构造完整的类反而变成了非主流。）

public class Commodity{

  private CommodityId id;
  private Category category;
  private String commodityName;
  private String description;
  private Date dateCreated;
  private Double price;

  public Commodity(CommodityId id, Category category, String commodityName, 
                              String description,  Date dateCreated, double price){

  }

}

如刚才所说，创建一个类，他必须符合业务逻辑的要求，
那检查是否符合要求则自然成了构造方法所要做的事情。最简单的如null检查

public Commodity(CommodityId id, Category category, String commodityName, 
                             String description,  Date dateCreated, double price){
  if(id == null){
    throw new IllegalArgumentException("id cannot be null.")
  }
  if(category == null){
    throw new IllegalArgumentException("category cannot be null.")
  }
  if(commodityName == null){
    throw new IllegalArgumentException("commodityName cannot be null.")
  }
  if(description == null){
    throw new IllegalArgumentException("description cannot be null.")
  }
  this.category = category;
  this.commodityName = commodityName;
  this.description = description;
  ...
}

再比如字数限定，还有更复杂的检查，比如保质期比可以比生产日期早等等。

  if(dateCreated > dateExpired){
    throw new IllegalArgumentException("dateCreated cannot be greater dateExpired");
  }

当这些逻辑变得复杂，构造方法就会变得很大，那类也当然会变得很大。
自然而然我们就能想到把这部分逻辑分到专门的类里，这就是Factory。

public CommodityFactory{

  public Commodity create(Commodity(CommodityId id, Category category, 
                                          String commodityName, String description,  Date dateCreated, double price)){
    if(id == null){
      throw new IllegalArgumentException("id cannot be null.")
    }
    if(category == null){
      throw new IllegalArgumentException("category cannot be null.")
    }
    if(commodityName == null){
      throw new IllegalArgumentException("commodityName cannot be null.")
    }
    if(description == null){
      throw new IllegalArgumentException("description cannot be null.")
    }
    return new Commodity(id, category, commodityName, description, dateCreated, price);
  }
}

这里是一个职责分离的思想，把类的实例构造逻辑从entity类移到了Factory里。
当然这是有些争议的地方，这些验证处理不是可以在entity类构造前，通过一些Validation的工具先处理掉。
个人觉得domain object是保证数据完整性的最后防线，所以我比较倾向把这些逻辑放在domain object，
然后抛出异常，然后在前台，或者application层根据异常来做处理。

承接一下开头提到的aggregate的数据完整性的话。在ddd的使用factory时，会使用factory来构建aggregate（根entity）。
aggregate是一个要求数据完整和不变性（invariant)的单位，对aggregate的验证自然也会写在Factory类中。
比如，一个商品需要有标签，但标签不能超过三个（开头开腿说过人只能有两条腿～）。
那Commodity这个entity/repository里会有CommodityTag这个表示标签的value object。

Commodity(CommodityId id, Category category, String commodityName, 
              String description,  Date dateCreated, double price, List<CommodityTag> tags){
  ...
  if(tags.size == 0){
    throw new IllegalArgumentException("tags cannot be empty.")
  }
  if(tags.size > 3){
    throw new IllegalArgumentException("tags cannot be over 3.")
  }
  ...
}

Specification
之前说到过，domain object是通过Repository来永久化的，一种Aggregate对应一个Repository。
Repository一般提供findById()的方法，把aggregate给返回。
但如果碰到一些比较复杂的查询逻辑，findById()就不够用了，
但我们肯定又不想每次有新的查询逻辑就创建一个新的方法，于是就用Specification pattern来解决这个问题。
在ICommodityRepository中定义方法

interface ICommodityRepository{
  Commodity find(ICommoditySpecification spec);
}
1
2
3
定义Specification接口，这里toQuery的返回值是和实际的实现相关的，假设用hibernate的话，就返回Criteria。

interface ICommoditySpecification{
  Criterion toQuery();
}

然后可以根据不同的查询逻辑建立不同的Specification类
通过id来查询的Specification

@AllArgsConstructor
public class CommoditySpecificationById implements ICommoditySpecification{
  private CommodityId id;

  public Criterion toQuery(){
    return Restrictions.eq("commodityId", id);
  }

}

通过产品名称来查询的Specification

@AllArgsConstructor
public class CommoditySpecificationByName implements ICommoditySpecification{
  private CommodityName commodityName;

  public Criterion toQuery(){
    return Restrictions.eq("commodity_name", commodityName);
  }

}

大概是这个思路。
另外Specification把查询的条件也抽象化了，理论上可以解除domain和具体db实现的依赖关系。
比如我们不用hibernate了，而使用更底层的sql语句，那可以改写成下面那样。

interface ICommoditySpecification{
  String toQuery();
}

@AllArgsConstructor
public class CommoditySpecificationByName implements ICommoditySpecification{
  private CommodityName commodityName;

  public String toQuery(){
    return "select * from commodity where commodity_name = " + 
  }

}

假设我们连db都变掉了，变成nosql，那理论上我们只需修改Specification和Repository的实现，而不会影响到domain的逻辑。
细心的朋友可能注意到，我迟迟没有讲关于Repository的实现。没有Repository的实现，那Specification的实现是没有意义的，他们两个是相互依赖的。
那么下一篇文章终于还是要讲一讲Repository的实现方法了。突然觉得压力好大！
上一篇文章讲到了Specification这个特殊的类，它是用来封装搜索的条件，也讲到了它的实现。
然而Specification和Repository二者的实现是相关的，那这次就来讲一讲Repository的实现。

预备知识
复习一下Repository是什么
从字面意思上讲repository是类似于仓库的意思。那在ddd中，它便是存放domain object （entity, value object）的东西。
需要指出的是它与service类的区别。Repository的职责仅是数据永久化。它将数据永久化的部分抽象，使domain层能够专注对业务逻辑的实现。
那理所当然repository是不能够包含业务逻辑的，所以我个人不推荐在repository定义像下面那样的方法。

  findPersonByName(String name);
  findAllPersonsByGroup(Group group);

在repository中应该吧查询条件更加抽象化，而起到这个作用的便是我们之前讲到的Specification。

实现的前提: 分层架构
还是略微提一下我们实现的repository是基于分层设计这个架构的。
按照分层设计分为以下三层:

application层
domain层 <– 定义repository
infrastructure层 <– 实现repository
实现repository
首先，这里仅谈论datasource是关系型数据库的实现。
repository和specifiction具体的实现其实是和db种类和选用的框架是有关系的，这里我们不能讲得面面俱到。
假设我们有一个表示商品的entity, Commodity。

public class Commodity {
    private Long commodityId;
    private String commodityName;
    private String description;

    /**
    * 用于reconstruct的构造方法
    */
    private Commodity(Long commodityId, String commodityName, String description){
      this.commodityId = commodityId;
      this.commodityName = commodityName;
      this.description = description;
    }
}

reconstruct
这里提一个概念叫reconstruct。
ddd中,domain object的实例化必须具有业务上的意义。很多情况下我们会用static的方法来表示其意义。比如

Commodity.createByName(commodityName);
1
这前我们还将过用Factory类来保证数据完整性。
但domain object还存在另一种实例化，那就是从db数据还原一个domain object。业务逻辑上没有因此增加一个domain object。
只是将已经存在的domain object从repository里重新取出，故称作reconstruct。
我们为reconstruct定义了一个构造方法。请大家注意，这个构造方法仅用于还原domain object，在实现业务逻辑是我们原则上是不能调用这个构造方法的!

Commodity这个entity对应一个数据表commodities

id	commodity_name	description
接口定义
我们定义一个IRepository接口，那应该开放哪些方法呢。我们写一下大致的构思。

public interface ICommodityRepository {
  // 查询一个Commodity
  Commodity findOne(ISpecification<Commodity> spec);
  // 查询满足要求的所有商品
  List<Commodity> find(ISpecification<Commodity> spec);
  // 删除
  void delete(Commodity commodity);
}

承接上面提到的内容，repository不应该包含业务逻辑，所以两个搜索的方法不包含任何业务的字眼，有关搜索条件全让Specification来定义。
然后具体的实例化的方法，会有两种方案。

add, update
  void add(Commodity commodity);
  void update(Commodity commodity);

save
  void save(Commodity commodity);

这个会是比较难得选择题。从repository这个设计模式的思想上来说，比较理想的是让业务逻辑不要在意究竟是增加还是更新，
只要关心把某个object存储就行。从这个角度来说save是更合适的。另外这个选择有时候取决于你选择的ORM。
可以选择ORM更容易实现的方式。

实现
大致的思路是Repository, Specification隐藏了具体关于ORM对于的实现，
所以RepositoryImpl, SpecificationImpl做的事情其实就是使用ORM的具体类来实现增删改查的功能。
比如jpa的话，基本就是把Specification转化为Predicate可以让EntityManager用来查询。
好了，之后基本就是关于ORM的事情了。

基于jpa的实现
jpa的实现，从代码量上面来说可能是最简洁的。不过与其说这是关于ddd的知识，更确切地说基本上完全是关于jpa的…

entity
我们必须对Commodity这个entity进行一些修改。加上与数据表映射用的信息。

@Entity
@Table(name = "commodities")
public class Commodity {
    @Id
    @Column(name = "ID", nullable = false)
    private Long commodityId;
    @Basic
    @Column(name = "COMMODITY_NAME", nullable = false)
    private String commodityName;
    @Basic
    @Column(name = "DESCRIPTION", nullable = false)
    private String description;
}

repository
repository也就是几行代码

public interface ICommodityRepository extends Repository<Commodity, Long>, JpaSpecificationExecutor<Commodity> {

}

specification
之前的实现看起来实在是太简单了，更令人惊喜的是，jpa还很良心地提供了Specification的接口。

/**
 * Specification in the sense of Domain Driven Design.
 * 
 * @author Oliver Gierke
 * @author Thomas Darimont
 */
public interface Specification<T> {

    /**
     * Creates a WHERE clause for a query of the referenced entity in form of a {@link Predicate} for the given
     * {@link Root} and {@link CriteriaQuery}.
     * 
     * @param root
     * @param query
     * @return a {@link Predicate}, must not be {@literal null}.
     */
    Predicate toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder cb);
}

连注释了都写domain driven design~
假设我们需要一个通过商品名来查询。那么我们可以定义一个。
jpa里使用Predicate（命题？）来封装具体的查询条件的，所以我们要实现一个返回Predicate的toPredicate()方法。如下。
Specification

@AllArgsConstructor
public class CommoditySpecByName extends Specification<Commodity> {

  @NonNull
  private String commodityName;

  @Override
  public Predicate toPredicate(Root<Poll> poll, CriteriaBuilder cb) {
    return cb.equal(root.get(Commodity_.commodityName, commodityName);
  }
}

然后具体使用时会是下面这样子

@Autowired
private ICommodityRepository commodityRepository;

pubic Commodity findCommodityByName(String commodityName){
  Commodity commodity = commodityRepository.findOne(new CommoditySpecByName(commodityName);
  return commodity;
}

关于jpa的实现
其实我们发现我们基本没有写什么具体实现，尤其是repository，只需定义一个接口，让它继承jpa的一些接口（好绕），jpa就会想变魔术一样，提供默认的实现。

指定repository开放的方法
JpaRepository开放了许多的方法，save(), findOne(), findAll(), count()等等。
jpa也只开放了save()这个方法，所以解决了一个本需要你烦恼的选择题。（除非你一定要选择insert/update）
但如果你觉得JpaRepository开放的方法太多了，很多根本不需要（比如delete(Entity entity)，count()），jpa还提供了其他的手段让你指定需要实现的方法）。
本来想写一下具体的内容，大家还是在需要时去查文档吧，只要知道有这个选项就行了

domain object与data object的分离
大家可以看到，使用jpa的话，在entity的类里要写一些与db映射的注解。
如果你有一些洁癖，不希望有这种依赖于db的信息，因为它实际上暴露具体的数据库实现。那自然而然你可能想要有一个专门与db映射的类，姑且称之为data object吧。
data object不是domain object，它没有业务的逻辑，只有关于db的一些信息。
那repository的实现就会变成

查询： 使用ORM查询得到data object, 将data object转化为domain object返回。
存储: domain object转化成data object, 使用ORM将它永久化。
而ddd关注的只是repository将domain object永久化的部分。它并不强求你去定义专门映射db的data model的。
其实使用data model这个手段不仅增加了需要定义的类，还增加了类转换的逻辑，而你能够得到的回报知识讲业务与数据的更大程度的分离。我认为是性价比很低的一个做法。
题外话，那为什么还要提这个手段呢？
直接的原因是因为自己工作的地方是采用了这种方式。而做出这个选择的理由是我们没有使用jpa（holy sh#t!）
结果就是我们很悲惨地定义了一大堆domain object。但在repository里，我们要将domain object转换成ORM需要使用的data object。真的是无比啰嗦，仓了个天啊。
所以当你的项目也有类似问题，觉得不用jpa就实现不了ddd时，不要放弃，其实也是有办法的，但是如果运气不好，你是用的ORM和ddd很不对路，那开发成本会变得比较大。

基于mybatis的实现
ORM的选择有千万种，我们再试试另一个比较流行的框架mybatis。看看使用它时该如何实现Repository。

specification
定义一个specification接口，它的toQuery()方法返回sql语句。

public interface ICommoditySpecification {
  String toQuery();
}

和之前例子一样，我们写一个用商品名来获取商品的specification。

@AllArgsConstructor
public class CommoditySpecByName implements ICommoditySpecification {

  @NonNull
  private String commodityName;

  @Override
  public String toQuery() {
    return "SELECT * FROM commodities WHERE commodityName = " + commodityName;
  }
}

repository
写一个mybatis用来处理commodities这张表的类

public interface CommodityMapper {
  @Results({
          @Result(property = "commodityId", column = "id"),
          @Result(property = "commodityName", column = "commodity_name"),
          @Result(property = "description", column = "description")
        })
  @Select("#{sql}")
  Commodity findOne(String sql);

  @Insert("INSERT into commodities(id, commodity_name, description) VALUES(#{commodityId}, #{commodityName}, #{description})")
  void add(Commodity commodity);

  @Update("UPDATE commodities SET commodity_name=#{commodityName}, description =#{description} WHERE commodity_id =#{id}")
  void update(Commodity commodity);

我们造了个万能的findOne()方法，它能接受任何查询，这是个潜在的安全性问题(估计在代买审核时，这个写法会被喷得体无完肤)。
当然这里只想说明repository的实现，所以这个问题先不管。

repository
public CommodityRepositoryImpl implements CommodityRepository{
  @Autowired
  private CommodityMapper commodityMapper;

  public Commodity findOne(ICommoditySpecification spec){
    commodityMapper.findOne(spec.toQuery());
  }

  public void add(Commodity commodity) {
    mapper.add(commodity);
  }

  public void update(Commodity commodity) {
    mapper.update(commodity);
  }

}

关于mybatis的实现
仅仅是写了一部分的实现，大家就可以看出相比于jpa，repository的实现类还是需要一定代码量的。
不过对喜欢写sql语句的人来说，mybatis也是个不错的ORM选择。而mybatis这个框架，努力一下还是能实现repository，specification模式的。

总结
这次通过jpa和mybatis的两个例子来说明了repository的实现方法。
相信大家已经找到了诀窍，无论是哪种ORM基本上都能实现Repository, Specification这个设计模式。当然成本可能千差万别。
到此为止我们基本上大致讲解了ddd的实现方法。之后还会在写一些文章来谈谈ddd战术方面的一些原则和建议。

--------------------------------------------------------------------------------

unit of work

你家来客人了，要泡茶。
一共几件事
1、烧开水  
2、拿茶叶
3、洗茶壶、茶杯
4、倒茶
UOW就是泡茶（包含上面那几件事）

也就是一个事务的控制过程
开启事务
持久化对象1
更新对象2
删除对象3
提交事务

从开始事务到提交事务的操作远程是一个工作单元，这样可以保证数据完整性
