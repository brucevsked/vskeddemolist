
软件的本质在于解决业务问题，以辅助业务而生存。
公司的业务创建的利润，所以合理解决业务问题才是关键。
这里的业务就是指一种领域
每一种业务都会涉及到一种知识体系，软件就是将这个知识体系表达出来。

3个基本用途决定模型选择
1 模型和设计核心互相影响
2 模型是团队所有成员使用通用语言的中枢
3 模型是浓缩的知识

有效建模的要素
1 模型和实现的绑定
2 建立了一种基于模型的语言
3 开发一个蕴含丰富知识的模型
4 提炼模型
5 头脑风暴和实验

规则类的处理可以使用策略模式来解决
要找出模型中隐藏概念（如允许超订10%）
示例代码允许 10%超订
原始代码
public int makeBooking(Cargo cargo,Voyage voyage){
  double maxBooking=voyage.capacity()*1.1;
  if((voyage.bookedCargoSize()+cargo.size())>maxBooking)
      return -1;
  int confirmation=orderConfirmationSequence.next();
  voyage.addCargo(cargo,confirmation);
  return confirmation;
}

修改后代码，把这条规则抽象出来
public boolean isAllowed(Cargo cargo,Voyage voyage){
  return (cargo.size()+voyage.bookedCargoSize())<=
            (voyage.capacity()*1.1);
}

public int makeBooking(Cargo cargo,Voyage voyage){
  if(!overbookingpolicy.isAllowed(cargo,voyage))
      return -1;
  int confirmation=orderConfirmationSequence.next();
  voyage.addCargo(cargo,confirmation);
  return confirmation;
}


模式 Ubiquitous Language统一语言
一个团队 一个项目 一种语言
将交流需求中用到的词语写到一个专门的文档中
词汇包括类与主要操作的名称
并不断更新这个文档中的词语与意思
每一个词语不应当有歧义，需要精确描述
对统一语言的修改就是对领域模型的修改


模式 Model-Driven Design 领域驱动设计

模式 Hands-On Modeler

模式 Layered Architecture
*用户界面层（或表示层）负责向用户显示信息和解释用户指令
这里的用户可以是另一个计算机系统，不一定是使用用户界面的人
*应用层 定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题。
这一层所负责的工作对业务来说意义重大，也是与其他系统的应用层进行交互的必要渠道。
应用层要尽量简单，不包含业务规则或者知识，只为下一层中的领域对象协调任务，分配工作
使他们互相协作。它没有反映业务情况的状态，但可以具有另外一种状态，为用户或程序显示某个任务的进度
*领域层（或模型层） 负责表达业务概念，业务状态信息以及业务规则。
尽管保存业务状态的技术细节是由基础设施层实现的，但是反映业务情况的状态是由本层控制并且使用的。
领域层是业务软件的核心
*基础设施层 为上面各层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制，
为用户界面层绘制屏幕组件，等等。基础设施层还能够通过架构框架来支持4个层次间的交互模式
网上银行分层示例
用户界面层 transferController
应用层 fundsTransferService
领域层 a123:Account,a234:Account 两个账户对象
基础设施层 unit of work manager(事务处理与持久化JPA),O-R Mapper(持久化对象模型DTO)
流程说明
1. transferController->tranfer(a123,a234,100) 要转账
控制层调用转账方法，传入要转账的两个账户与转账金额，三个参数源账户，目标账户，转账金额
2. FundsTransferService-beginTransaction()->Unit of Work Manager 开启事务
应用层调用基础设施层的持久化单元开启事务
3. FundsTransferService-transferTo(a234,100)->a123:Account 领域模型Account实例a123
应用层调用本层的转账方法此方法会通知领域层a123领域模型要向a234领域模型转100
4. a123:Account -credit(100)->a234:Account 领域模型Account实例a234
领域层a123领域模型授信给a234领域模型100
5. a234:Account -addToUnitOfWork(a234)->Unit of Work Manager
领域层a234领域模型通知基础层持久化单元（注意这时候并没真正存储到库里）
6. a234:Account-confirm->a123:account
领域层a234确认收到a123信用100
7. a123:Account-debit(100)-a123
领域层a123领域模型自己记账100
8. a123:Account-addToUnitOfWork(a123)->Unit of Work Manager
领域层a123领域模型通知基础层持久化单元（注意这时候并没真正存储到库里）
9. a123:Account-confirm->FundsTransferService
领域层模型通知应用层服务这活确认搞完了
10. FundsTransferService-commit()->Unit of Work Manager
应用层服务通知基础层持久化单元你可以真正持久化到数据库了
11.Unit of WorkManager -update(collection)->O-R Mapper
基础层通过持久化模型将刚才改好的两个领域模型转换为关系数据库模型保存到库

模式 Entity(Reference Objecct)

模式 Value Object

模式  Service

模式 Module(Package)

模式 Aggregate

模式 Factory

模式 Repository

模式 Intention-Revealing Interfaces

模式 Side-Effect-Free function 

模式 Assertion

模式 Conceptual Contour 

模式 Standalone Class 

模式 Closure of Operation

模式 Strategy(Policy)

模式 Composite

模式 Bounded Context

模式 Continuous Integration

模式 Context Map

模式 Shared Kernel

模式 Customer/Supplier Development Team

模式 Conformist

模式 Anticorruption Layer

模式 Separate Way

模式 Open Host Service

模式 Published Language

模式 Core Domain

模式 Generic Subdomain

模式 Domain Vision Statement

模式 Highlighted Core

模式 Cohesive Mechanism

模式 Segregated Core

模式 Abstract Core

模式 Evolving Order

模式 System Metaphor

模式 Responsibility Layer

模式 Knowledge Level

模式 Pluggable Component Framework



