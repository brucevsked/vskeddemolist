
当yml文件中配置为
  jpa:
    hibernate:
      ddl-auto: create
    show-sql: true
或值为
create-drop
时才会执行resources目录中的import.sql文件



Spring Data Jpa 中级联操作CascadeType的含义
CascadeType.PERSIST

级联新增，保存父对象时会新建其中包含的子对象

CascadeType.MERGE
级联修改，保存父对象时会更新其中所包含的子对象数据

CascadeType.REMOVE
级联删除，当删除关联关系时会将子对象的数据删除

CascadeType.REFRESH
级联刷新，保存关联关系时会更新子对象和数据库中一致
(意思是你在父对象中添加一个只包含ID的子对象，也可以保存进去)

CascadeType.ALL
包含上述所有操作
	@OneToMany(cascade=CascadeType.ALL,fetch=FetchType.EAGER)

fetch 加载方式
立即加载
FetchType.EAGER

懒加载
FetchType.LAZY


SpringDataJpa Specification接口用法
首先，我们需要了解到Specification是springDateJpa中的一个接口，
他是用于当jpa的一些基本CRUD操作的扩展，可以把他理解成一个spring jpa的复杂查询接口。
其次我们需要了解Criteria 查询，这是是一种类型安全和更面向对象的查询。
而Spring Data JPA支持JPA2.0的Criteria查询，相应的接口是JpaSpecificationExecutor。

而JpaSpecificationExecutor这个接口基本是围绕着Specification接口来定义的， Specification接口中只定义了如下一个方法：

Predicate toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder cb); 

下面，我们来理解这个方法，首先，要理解这个方法，以及正确的使用它，
就需要对JPA2.0的Criteria查询有一个足够的熟悉和理解，因为这个方法的参数和返回值都是JPA标准里面定义的对象。 

Criteria查询基本概念

Criteria 查询是以元模型的概念为基础的，元模型是为具体持久化单元的受管实体定义的，这些实体可以是实体类，嵌入类或者映射的父类。

CriteriaQuery接口：代表一个specific的顶层查询对象，它包含着查询的各个部分，
比如：select 、from、where、group by、order by等注意：CriteriaQuery对象只对实体类型或嵌入式类型的Criteria查询起作用

Root接口：代表Criteria查询的根对象，Criteria查询的查询根定义了实体类型，能为将来导航获得想要的结果，它与SQL查询中的FROM子句类似

1：Root实例是类型化的，且定义了查询的FROM子句中能够出现的类型。
root代表查询的实体类,query可以从中得到root对象,告诉jpa查询哪一个实体类,
还可以添加查询条件,还可以结合EntityManager对象 得到最终查询的 TypedQuery对象.

2：查询根实例能通过传入一个实体类型给 AbstractQuery.from方法获得。

3：Criteria查询，可以有多个查询根。 

4.CriteriaBuilder接口：用来构建CritiaQuery的构建器对象
Predicate：一个简单或复杂的谓词类型，其实就相当于条件或者是条件组合。 


建表时不使用下划线命名
  jpa:
    hibernate:
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

Spring Data JPA是个非常强大的ORM持久化解决方案，免去了mybatis或spring jdbcTemplate的开发人员编写脚本的无趣工作。

通过简单明了地约定好接口方法的规则，来自动生成相应的JPQL语句，映射成PO对象，能大幅节省开发人员的编码量。

接口方法的命名规则也很简单，明白And、Or、Is、Equal、Greater、StartingWith等英文单词的含义，就可以写接口方法了。

以下是从Spring Data JPA官方网站上的docs整理而来，网上其他有些文章写的有的是错的，

大于等于、小于等于应为：GreaterThanEqual、LessThanEqual，而不是GreaterThanEquals、LessThanEquals，如果带了s，会导致程序启动报错。

关键词            |   SQL符号            |样例                                                   | 对应JPQL 语句片段
And              |	  and	              | findByLastnameAndFirstname  |	 … where x.lastname = ?1 and x.firstname = ?2
Or	             |    or	              | findByLastnameOrFirstname   | … where x.lastname = ?1 or x.firstname = ?2
Is,Equals        |    =	                | findByFirstname,findByFirstnameIs,findByFirstnameEquals| … where x.firstname = ?1
Between	         | between xxx and xxx	|findByStartDateBetween	… where x.startDate between ?1 and ?2
LessThan	       |   <	                |findByAgeLessThan	… where x.age < ?1
LessThanEqual	   |<=	findByAgeLessThanEqual	… where x.age <= ?1
GreaterThan	     |>	findByAgeGreaterThan	… where x.age > ?1
GreaterThanEqual |	>=	findByAgeGreaterThanEqual	… where x.age >= ?1
After	>	findByStartDateAfter	… where x.startDate > ?1
Before	<	findByStartDateBefore	… where x.startDate < ?1
IsNull	is null	findByAgeIsNull	… where x.age is null
IsNotNull,NotNull	is not null	findByAge(Is)NotNull	… where x.age not null
Like	like	findByFirstnameLike	… where x.firstname like ?1
NotLike	not like	findByFirstnameNotLike	… where x.firstname not like ?1
StartingWith	like 'xxx%'	findByFirstnameStartingWith	… where x.firstname like ?1(parameter bound with appended %)
EndingWith	like 'xxx%'	findByFirstnameEndingWith	… where x.firstname like ?1(parameter bound with prepended %)
Containing	like '%xxx%'	findByFirstnameContaining	… where x.firstname like ?1(parameter bound wrapped in %)
OrderBy	order by	findByAgeOrderByLastnameDesc	… where x.age = ?1 order by x.lastname desc
Not	<>	findByLastnameNot	… where x.lastname <> ?1
In	in()	findByAgeIn(Collection<Age> ages)	… where x.age in ?1
NotIn	not in()	findByAgeNotIn(Collection<Age> ages)	… where x.age not in ?1
TRUE	=true	findByActiveTrue()	… where x.active = true
FALSE	=false	findByActiveFalse()	… where x.active = false
IgnoreCase	upper(xxx)=upper(yyyy)	findByFirstnameIgnoreCase	… where UPPER(x.firstame) = UPPER(?1)


对于mappedBy用法：

　　a） 只有OneToOne,OneToMany,ManyToMany上才有mappedBy属性，ManyToOne不存在该属性；

　　b） mappedBy标签一定是定义在the owned side（被拥有方的），他指向theowning side（拥有方）；

　　c） 关系的拥有方负责关系的维护，在拥有方建立外键。所以用到@JoinColumn

　　d）mappedBy跟JoinColumn/JoinTable总是处于互斥的一方，也就是说一个类写了JoinColumn/JoinTable另一个类才会写mappedBy

两个类用户类与证书类是一对一的关系

@Table(name = "user5")
@Entity
public class User5PO implements Serializable {
    @Id
    private Long id;
    private String name;
    //保存用户时会保存证书类，但保存证书类时不会保存用户类，因为这里关系是由用户类来维护的
    @OneToOne(cascade = CascadeType.ALL)
    @JoinTable(name = "userCertificate5",joinColumns = {@JoinColumn(name = "userId")},inverseJoinColumns = {@JoinColumn(name = "certificateId")})
    private Certificate5PO certificate;
}


@Table(name = "certificate5")
@Entity
public class Certificate5PO implements Serializable {

    @Transient//此字段不需要持久化到数据库
    private static final long serialVersionUID = -4996099625666042353L;

    @Id
    private Long id;
    private String content;
    
    @OneToOne(mappedBy = "certificate")
    private User5PO user;
}

mappedBy表示声明自己不是一对多的关系维护端，由对方来维护，是在一的一方进行声明的。mappedBy的值应该为一的一方的表名
中间表示例
JoinTable joinColumns当前对象(SystemObjectEntity)唯一标识名称(如本对象中叫id中间表中叫systemObjectId)，
inverseJoinColumns子对象唯一标识ObjectActionEntity(如子对象唯一标识列为id,中间表中名称叫objectActionId)
    @OneToMany(cascade = CascadeType.ALL)
    @JoinTable(name = "rolePermission3",joinColumns = {@JoinColumn(name = "roleId")},inverseJoinColumns = {@JoinColumn(name = "permissionId")})
    List<PermissionPO> permissions=new LinkedList<>();
    


@Embedded 和 @Embeddable
指定其值为可嵌入类实例的实体的持久字段或属性。
可嵌入类必须标注为Embeddable。
 @Embedded 用来修饰 对象属性(引用类型 -- 类对象 -- 属性注解)
 @Embeddable 用来修饰 类(类注解)
 用来复用类对象的属性 可使用 @AttributeOverrides 来进行重写
  如 AttributeOverride，AttributeOverrides， 
  AssociationOverride，和AssociationOverrides 
  注释可以用于覆盖声明或嵌入类默认映射。 


对象关联关系说明
假设有类book,bookCategory两个实体
1所有关系说明都是从本实体出发，到目标实体的

多对1关系示例（多本书对应同一个分类）
@Entity
public class Book {
    @Id
    private int id;
    private String name;

    @ManyToOne
    @JoinColumn(name = "book_category_id")
    private BookCategory bookCategory;

}

一对多关系示例(一个分类对应多本书)
@Entity
@Table(name = "book_category")
public class BookCategory {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;
    private String name;

    @OneToMany(mappedBy = "bookCategory", cascade = CascadeType.ALL)
    private Set<Book> books;

}


命名+带分页方式
    Page<ArticleDO> findAllByAccountIdIsAndMenuIdIs(Long menuId, Long accountId, Pageable pageable);

@Entity
@Table(name="menu")
public class MenuDO {
	
	@Id
    private Long id;

	/**
	 * 菜单文本
	 */
	private String text;
	
	private String link;
	
	private Integer level;
	
	private Integer sequence;

	private Long parentId;
	
	@OneToMany(cascade=CascadeType.ALL,fetch=FetchType.EAGER)
	@JoinColumn(name = "parentId")
	private Set<MenuDO> subMenus;

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getText() {
		return text;
	}

	public void setText(String text) {
		this.text = text;
	}

	public String getLink() {
		return link;
	}

	public void setLink(String link) {
		this.link = link;
	}

	public Integer getLevel() {
		return level;
	}

	public void setLevel(Integer level) {
		this.level = level;
	}

	public Integer getSequence() {
		return sequence;
	}

	public void setSequence(Integer sequence) {
		this.sequence = sequence;
	}

	public Long getParentId() {
		return parentId;
	}

	public void setParentId(Long parentId) {
		this.parentId = parentId;
	}

	public Set<MenuDO> getSubMenus() {
		return subMenus;
	}

	public void setSubMenus(Set<MenuDO> subMenus) {
		this.subMenus = subMenus;
	}

	public MenuDO() {
		super();
	}

	public MenuDO(Long id, String text, String link, Integer level, Integer sequence, Long parentId) {
		super();
		this.id = id;
		this.text = text;
		this.link = link;
		this.level = level;
		this.sequence = sequence;
		this.parentId = parentId;
	}

    @Override
    public String toString() {
        return "{" +
                "\"id\":" +id.longValue()+
                ", \"text\":\"" + text +
                "\", \"link\":\"" + link  +
                "\",\"level\":" + (level==null?"-1":level.intValue()) +
                ", \"sequence\":" + sequence.intValue() +
                ", \"parentId\":" + (parentId==null?"0":parentId.longValue())+
				", \"subMenus\":" + ((subMenus==null)?"[]":subMenus.toString())+
                "}";
    }
	
	

}




@Entity
@Table(name="article")
public class ArticleDO {
	
	@Id
    private Long id;

    private String title;
    
    private String content;
    
    @JoinColumn(table = "account",name = "id")
    private Long accountId;

    @OneToOne(fetch=FetchType.EAGER)
	@JoinColumn(name = "menuId")
    private MenuDO menu;

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public Long getAccountId() {
		return accountId;
	}

	public void setAccountId(Long accountId) {
		this.accountId = accountId;
	}

	public MenuDO getMenu() {
		return menu;
	}

	public void setMenu(MenuDO menu) {
		this.menu = menu;
	}

	public ArticleDO() {
		super();
	}

	public ArticleDO(Long id, String title, String content, Long accountId) {
		super();
		this.id = id;
		this.title = title;
		this.content = content;
		this.accountId = accountId;
	}
    
    @Override
    public String toString() {
        return "{" +
                "\"id\":" + id.longValue() +
                ", \"title\":\"" + title +
                "\", \"content\":\"" + content +
				"\", \"menu\":" + menu.toString() +
                "}";
    }
    

}

对象中有子对象
左连接示例


package com.jat.repository.back.specification;

import com.jat.dto.back.ArticleDO;
import com.jat.vo.ArticleQueryVO;
import org.springframework.data.jpa.domain.Specification;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Join;
import javax.persistence.criteria.JoinType;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;

public class ArticleSpecification implements Specification<ArticleDO> {

    private ArticleQueryVO articleQueryVO;

    public ArticleSpecification(ArticleQueryVO articleQueryVO) {
        this.articleQueryVO = articleQueryVO;
    }

    public Predicate toPredicate(Root<ArticleDO> root, CriteriaQuery<?> criteriaQuery, CriteriaBuilder criteriaBuilder) {

        Predicate titlePredicate=criteriaBuilder.like(root.get("title"),"%"+articleQueryVO.getTitle()+"%");
        Predicate contentPredicate=criteriaBuilder.like(root.get("content"),"%"+articleQueryVO.getContent()+"%");

        if(articleQueryVO.getMenuId()==null || articleQueryVO.getMenuId().intValue()==-1){
            return criteriaBuilder.and(titlePredicate,contentPredicate);
        }

        Join menuJoin=root.join("menu", JoinType.LEFT);
        Predicate menuIdPredicate=criteriaBuilder.equal(menuJoin.get("id"),articleQueryVO.getMenuId());
        return criteriaBuilder.and(titlePredicate,contentPredicate,menuIdPredicate);

    }
}


联合主键，无外键关联版本
package com.vsked.entity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Table(name = "student")
@Entity
public class Student {

    @Id
    @Column(name = "id")
    private long id;

    @Column(name = "sname")
    private String sname;

    public Student() {
    }

    public Student(long id, String sname) {
        this.id = id;
        this.sname = sname;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getSname() {
        return sname;
    }

    public void setSname(String sname) {
        this.sname = sname;
    }
}

package com.vsked.entity;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Table(name = "score")
@Entity
public class Score {

    @Id
    @Column(name = "id")
    private long id;

    @Column(name = "score")
    private int score;

    public Score() {
    }

    public Score(long id, int score) {
        this.id = id;
        this.score = score;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public int getScore() {
        return score;
    }

    public void setScore(int score) {
        this.score = score;
    }
}

package com.vsked.entity;

import javax.persistence.Embeddable;
import java.io.Serializable;

@Embeddable
public class StudentScoreKey implements Serializable {

    private long studentId;

    private long scoreId;

    public StudentScoreKey() {
    }

    public StudentScoreKey(long studentId, long scoreId) {
        this.studentId = studentId;
        this.scoreId = scoreId;
    }

    public long getStudentId() {
        return studentId;
    }

    public void setStudentId(long studentId) {
        this.studentId = studentId;
    }

    public long getScoreId() {
        return scoreId;
    }

    public void setScoreId(long scoreId) {
        this.scoreId = scoreId;
    }
}

package com.vsked.entity;

import javax.persistence.EmbeddedId;
import javax.persistence.Entity;
import javax.persistence.Table;

@Table(name = "studentScore")
@Entity
public class StudentScore {

    @EmbeddedId
    StudentScoreKey studentScoreKey;

    public StudentScore() {
    }

    public StudentScore(StudentScoreKey studentScoreKey) {
        this.studentScoreKey = studentScoreKey;
    }

    public StudentScoreKey getStudentScoreKey() {
        return studentScoreKey;
    }

    public void setStudentScoreKey(StudentScoreKey studentScoreKey) {
        this.studentScoreKey = studentScoreKey;
    }
}


中间表示例
JoinTable joinColumns当前对象(SystemObjectEntity)唯一标识名称(如本对象中叫id中间表中叫systemObjectId)，
inverseJoinColumns子对象唯一标识ObjectActionEntity(如子对象唯一标识列为id,中间表中名称叫objectActionId)

@Table(name = "systemObject")
@Entity
public class SystemObjectEntity {

    @Id
    @Column(name = "id")
    private String id;

    @OneToMany(cascade= CascadeType.ALL)
    @JoinTable(name = "systemObjectAction",joinColumns = {@JoinColumn(name = "systemObjectId")},inverseJoinColumns = {@JoinColumn(name = "objectActionId")})
    private Set<ObjectActionEntity> actionEntitySet;
}



单向一对一

@Entity
public class Student {

    @Id
    @Column(insertable = false, updatable = false, columnDefinition = "INT UNSIGNED  COMMENT '学生ID'")
    private Integer studentId;

    @Column(length = 50, columnDefinition = "VARCHAR(255) NOT NULL COMMENT '学生名'")
    private String studentName;

    @OneToOne
    @JoinColumn(name = "teacher_id", referencedColumnName = "teacherId")
    //设置生成的外键名称为teacher_id，对应Teacher类中的teacherId
    private Teacher teacher;


}

@Entity
public class Teacher {

    @Id
    @Column(insertable = false, updatable = false, columnDefinition = "INT UNSIGNED COMMENT '教师ID'")
    private Integer teacherId;

    @Column(length = 50, columnDefinition = "VARCHAR(255) NOT NULL COMMENT '教师名'")
    private String teacherName;

}


双向一对一

@Entity
public class Student {

    @Id
    @Column(insertable = false, updatable = false, columnDefinition = "INT UNSIGNED  COMMENT '学生ID'")
    private Integer studentId;

    @Column(length = 50, columnDefinition = "VARCHAR(255) NOT NULL COMMENT '学生名'")
    private String studentName;

    @OneToOne
    @JoinColumn(name = "teacher_id", referencedColumnName = "teacherId")
    //设置生成的外键名称为teacher_id，对应Teacher类中的teacherId
    private Teacher teacher;


}

@Entity
public class Teacher {

    @Id
    @Column(insertable = false, updatable = false, columnDefinition = "INT UNSIGNED COMMENT '教师ID'")
    private Integer teacherId;

    @Column(length = 50, columnDefinition = "VARCHAR(255) NOT NULL COMMENT '教师名'")
    private String teacherName;

    @OneToOne(mappedBy = "teacher")//对应Student中的Teacher对象的名字
    private Student student;

}
